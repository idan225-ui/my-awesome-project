<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ויזואליזציה אינטראקטיבית של למידה מכונה</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            min-height: 100vh;
            padding: 20px;
            direction: rtl;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: #ffffff;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
            letter-spacing: 2px;
        }

        .header p {
            color: #999;
            font-size: 0.9em;
            letter-spacing: 1px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }

        .tab {
            padding: 15px 30px;
            background: #2a2a2a;
            color: #ffffff;
            border: 2px solid #444;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 500;
            transition: all 0.3s;
        }

        .tab:hover {
            background: #333;
            border-color: #666;
        }

        .tab.active {
            background: #ffffff;
            color: #000000;
            border-color: #ffffff;
            box-shadow: 0 2px 8px rgba(255,255,255,0.1);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .section {
            background: #2a2a2a;
            padding: 30px;
            border-radius: 4px;
            border: 1px solid #444;
            margin-bottom: 25px;
        }

        .section-title {
            font-size: 1.8em;
            font-weight: 300;
            color: #ffffff;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #666;
            letter-spacing: 1px;
        }

        .section-description {
            color: #cccccc;
            font-size: 1.1em;
            margin-bottom: 25px;
            line-height: 1.6;
        }

        .canvas-container {
            background: #1a1a1a;
            border-radius: 4px;
            padding: 20px;
            margin-bottom: 20px;
            position: relative;
            border: 1px solid #444;
        }

        canvas {
            border: 2px solid #666;
            border-radius: 4px;
            cursor: crosshair;
            background: #ffffff;
            display: block;
            margin: 0 auto;
        }

        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 20px;
            align-items: center;
        }

        .btn {
            padding: 12px 25px;
            background: #444;
            color: #ffffff;
            border: 1px solid #666;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        .btn:hover {
            background: #555;
            border-color: #777;
        }

        .btn-secondary {
            background: #333;
        }

        .btn-secondary:hover {
            background: #444;
        }

        .btn-success {
            background: #555;
        }

        .btn-success:hover {
            background: #666;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 200px;
        }

        .slider-container label {
            font-weight: 500;
            color: #cccccc;
            font-size: 0.9em;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #444;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            border: 2px solid #666;
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            border: 2px solid #666;
        }

        .info-box {
            background: #333;
            color: #ffffff;
            padding: 20px;
            border-radius: 4px;
            margin-top: 20px;
            border: 1px solid #555;
        }

        .info-box h3 {
            margin-bottom: 10px;
            font-size: 1.3em;
            font-weight: 300;
            color: #ffffff;
        }

        .info-box p {
            line-height: 1.6;
            margin-bottom: 10px;
            color: #cccccc;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background: #333;
            padding: 20px;
            border-radius: 4px;
            border: 1px solid #555;
        }

        .card h4 {
            color: #ffffff;
            margin-bottom: 10px;
            font-size: 1.2em;
            font-weight: 500;
        }

        .card p {
            color: #cccccc;
            line-height: 1.5;
        }

        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }

        .status {
            padding: 10px 15px;
            background: #444;
            color: #ffffff;
            border-radius: 4px;
            margin-top: 15px;
            font-weight: 500;
            text-align: center;
            border: 1px solid #666;
        }

        .status.error {
            background: #333;
            color: #ff6666;
            border-color: #ff6666;
        }

        .status.info {
            background: #333;
            color: #ffffff;
            border-color: #666;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8em;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .tab {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ויזואליזציה אינטראקטיבית של למידה מכונה</h1>
            <p>Interactive Machine Learning Visualizations</p>
        </div>

        <div class="tabs">
            <div class="tab active" onclick="switchTab('supervised')">למידה מונחית</div>
            <div class="tab" onclick="switchTab('unsupervised')">למידה לא מונחית</div>
            <div class="tab" onclick="switchTab('reinforcement')">למידה חיזוק</div>
            <div class="tab" onclick="switchTab('deep')">למידה עמוקה</div>
        </div>

        <!-- Supervised Learning -->
        <div class="tab-content active" id="tab-supervised">
            <div class="section">
                <div class="section-title">למידה מונחית (Supervised Learning)</div>
                <div class="section-description">
                    למידה מונחית היא סוג של למידה מכונה שבה האלגוריתם לומד מתוך דוגמאות מתויגות.
                    המטרה היא ללמוד פונקציה שממפה קלט לפלט רצוי.
                </div>

                <div class="grid">
                    <div class="card">
                        <h4>סיווג (Classification)</h4>
                        <p>מטרת הסיווג היא לקבץ נתונים לקטגוריות מוגדרות מראש. לדוגמה: זיהוי ספאם, זיהוי תמונות, אבחון רפואי.</p>
                    </div>
                    <div class="card">
                        <h4>רגרסיה (Regression)</h4>
                        <p>מטרת הרגרסיה היא לחזות ערך רציף. לדוגמה: חיזוי מחירי בתים, חיזוי טמפרטורה, חיזוי מכירות.</p>
                    </div>
                </div>

                <div class="controls">
                    <button class="btn" onclick="initClassification()">התחל סיווג</button>
                    <button class="btn btn-secondary" onclick="initRegression()">התחל רגרסיה</button>
                    <button class="btn btn-success" onclick="trainModel()">אמן מודל</button>
                    <button class="btn" onclick="clearCanvas()">נקה</button>
                </div>

                <div class="canvas-container">
                    <canvas id="supervisedCanvas" width="800" height="500"></canvas>
                    <div class="legend" id="supervisedLegend"></div>
                    <div class="status" id="supervisedStatus">לחץ על "התחל סיווג" או "התחל רגרסיה" כדי להתחיל</div>
                </div>

                <div class="info-box">
                    <h3>איך זה עובד?</h3>
                    <p><strong>סיווג:</strong> צייר נקודות בשני צבעים שונים (שחור ואפור). המודל ילמד להפריד בין הקטגוריות ויצייר קו הפרדה.</p>
                    <p><strong>רגרסיה:</strong> צייר נקודות על הגרף. המודל ילמד את הקשר בין X ל-Y ויצייר קו מגמה.</p>
                </div>
            </div>
        </div>

        <!-- Unsupervised Learning -->
        <div class="tab-content" id="tab-unsupervised">
            <div class="section">
                <div class="section-title">למידה לא מונחית (Unsupervised Learning)</div>
                <div class="section-description">
                    למידה לא מונחית היא סוג של למידה מכונה שבה האלגוריתם מחפש דפוסים בנתונים ללא תוויות.
                    המטרה היא לגלות מבנה חבוי בנתונים.
                </div>

                <div class="grid">
                    <div class="card">
                        <h4>קיבוץ (Clustering)</h4>
                        <p>מטרת הקיבוץ היא לקבץ נקודות דומות יחד ללא ידיעה מראש כמה קבוצות יש. לדוגמה: קטלוג לקוחות, זיהוי אנומליות.</p>
                    </div>
                    <div class="card">
                        <h4>הפחתת ממדים (Dimensionality Reduction)</h4>
                        <p>מטרת הפחתת הממדים היא להציג נתונים רב-ממדיים במרחב דו-ממדי תוך שמירה על המבנה המקורי.</p>
                    </div>
                </div>

                <div class="controls">
                    <button class="btn" onclick="initClustering()">התחל קיבוץ</button>
                    <button class="btn btn-secondary" onclick="initPCA()">התחל PCA</button>
                    <div class="slider-container">
                        <label>מספר קבוצות (K): <span id="kValue">3</span></label>
                        <input type="range" class="slider" id="kSlider" min="2" max="8" value="3" oninput="updateKValue()">
                    </div>
                    <button class="btn btn-success" onclick="runClustering()">הרץ קיבוץ</button>
                    <button class="btn" onclick="clearUnsupervisedCanvas()">נקה</button>
                </div>

                <div class="canvas-container">
                    <canvas id="unsupervisedCanvas" width="800" height="500"></canvas>
                    <div class="legend" id="unsupervisedLegend"></div>
                    <div class="status" id="unsupervisedStatus">לחץ על "התחל קיבוץ" או "התחל PCA" כדי להתחיל</div>
                </div>

                <div class="info-box">
                    <h3>איך זה עובד?</h3>
                    <p><strong>K-Means Clustering:</strong> האלגוריתם מחפש K מרכזי קבוצות ומקבץ את כל הנקודות לקבוצה הקרובה ביותר.</p>
                    <p><strong>PCA:</strong> האלגוריתם מוצא את הכיוונים שבהם השונות היא הגדולה ביותר ומציג את הנתונים עליהם.</p>
                </div>
            </div>
        </div>

        <!-- Reinforcement Learning -->
        <div class="tab-content" id="tab-reinforcement">
            <div class="section">
                <div class="section-title">למידה חיזוק (Reinforcement Learning)</div>
                <div class="section-description">
                    למידה חיזוק היא סוג של למידה מכונה שבה סוכן לומד לפעול בסביבה על ידי קבלת תגמולים או עונשים.
                    המטרה היא למקסם את התגמול המצטבר לאורך זמן.
                </div>

                <div class="grid">
                    <div class="card">
                        <h4>Q-Learning</h4>
                        <p>אלגוריתם למידה חיזוק שמלמד את הסוכן את הערך של פעולות במצבים שונים.</p>
                    </div>
                    <div class="card">
                        <h4>Policy Gradient</h4>
                        <p>אלגוריתם שמלמד את הסוכן מדיניות ישירה של פעולות ללא טבלת Q.</p>
                    </div>
                </div>

                <div class="controls">
                    <button class="btn" onclick="initRL()">התחל משחק</button>
                    <button class="btn btn-success" onclick="trainRL()">אמן סוכן</button>
                    <button class="btn" onclick="resetRL()">איפוס</button>
                    <div class="slider-container">
                        <label>מהירות: <span id="speedValue">50</span>ms</label>
                        <input type="range" class="slider" id="speedSlider" min="10" max="200" value="50" oninput="updateSpeed()">
                    </div>
                </div>

                <div class="canvas-container">
                    <canvas id="rlCanvas" width="800" height="500"></canvas>
                    <div class="status" id="rlStatus">לחץ על "התחל משחק" כדי להתחיל</div>
                </div>

                <div class="info-box">
                    <h3>איך זה עובד?</h3>
                    <p>הסוכן (שחור) צריך להגיע למטרה (לבן) תוך הימנעות ממכשולים (אפור).</p>
                    <p>הסוכן מקבל תגמול חיובי כשהוא מגיע למטרה ותגמול שלילי כשהוא נתקל במכשול.</p>
                    <p>בכל איטרציה הסוכן לומד ומשפר את הביצועים שלו.</p>
                </div>
            </div>
        </div>

        <!-- Deep Learning -->
        <div class="tab-content" id="tab-deep">
            <div class="section">
                <div class="section-title">למידה עמוקה (Deep Learning)</div>
                <div class="section-description">
                    למידה עמוקה היא תת-תחום של למידה מכונה המשתמש ברשתות נוירונים מלאכותיות עם שכבות מרובות.
                    רשתות אלה יכולות ללמוד ייצוגים מורכבים של נתונים.
                </div>

                <div class="grid">
                    <div class="card">
                        <h4>רשת נוירונים (Neural Network)</h4>
                        <p>רשת של נוירונים מחוברים שמעבדת מידע דרך שכבות מרובות. כל נוירון מחשב פונקציה של הקלטים שלו.</p>
                    </div>
                    <div class="card">
                        <h4>Backpropagation</h4>
                        <p>אלגוריתם אימון שמפיץ שגיאות אחורה דרך הרשת ומעדכן את המשקולות כדי לשפר את הביצועים.</p>
                    </div>
                </div>

                <div class="controls">
                    <button class="btn" onclick="initNeuralNetwork()">צור רשת</button>
                    <div class="slider-container">
                        <label>מספר שכבות: <span id="layersValue">3</span></label>
                        <input type="range" class="slider" id="layersSlider" min="2" max="6" value="3" oninput="updateLayers()">
                    </div>
                    <div class="slider-container">
                        <label>נוירונים בשכבה: <span id="neuronsValue">4</span></label>
                        <input type="range" class="slider" id="neuronsSlider" min="2" max="8" value="4" oninput="updateNeurons()">
                    </div>
                    <button class="btn btn-success" onclick="trainNeuralNetwork()">אמן רשת</button>
                    <button class="btn" onclick="resetNeuralNetwork()">איפוס</button>
                </div>

                <div class="canvas-container">
                    <canvas id="deepCanvas" width="800" height="500"></canvas>
                    <div class="status" id="deepStatus">לחץ על "צור רשת" כדי להתחיל</div>
                </div>

                <div class="info-box">
                    <h3>איך זה עובד?</h3>
                    <p>הרשת מורכבת משכבות של נוירונים. כל נוירון מקבל קלטים, מחשב סכום משוקלל ומעביר דרך פונקציית הפעלה.</p>
                    <p>בתהליך האימון, הרשת לומדת את המשקולות האופטימליות על ידי הפצת שגיאות אחורה (backpropagation).</p>
                    <p>ככל שהרשת עמוקה יותר (יותר שכבות), היא יכולה ללמוד דפוסים מורכבים יותר.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentMode = 'supervised';
        let supervisedMode = null; // 'classification' or 'regression'
        let supervisedData = { classification: [], regression: [] };
        let unsupervisedMode = null;
        let unsupervisedData = [];
        let clusters = [];
        let rlAgent = null;
        let rlGame = null;
        let neuralNetwork = null;
        let animationSpeed = 50;

        // Tab switching
        function switchTab(tab) {
            currentMode = tab;
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(`tab-${tab}`).classList.add('active');
        }

        // ========== SUPERVISED LEARNING ==========
        const supervisedCanvas = document.getElementById('supervisedCanvas');
        const supervisedCtx = supervisedCanvas.getContext('2d');
        let currentClass = 0; // 0 = blue, 1 = red

        function initClassification() {
            supervisedMode = 'classification';
            supervisedData.classification = [];
            currentClass = 0;
            clearSupervisedCanvas();
            updateSupervisedStatus('סיווג: לחץ על הקנבס כדי להוסיף נקודות. לחץ על "אמן מודל" כדי להפריד בין הקטגוריות.');
            drawSupervisedCanvas();
        }

        function initRegression() {
            supervisedMode = 'regression';
            supervisedData.regression = [];
            clearSupervisedCanvas();
            updateSupervisedStatus('רגרסיה: לחץ על הקנבס כדי להוסיף נקודות. לחץ על "אמן מודל" כדי לצייר קו מגמה.');
            drawSupervisedCanvas();
        }

        supervisedCanvas.addEventListener('click', (e) => {
            const rect = supervisedCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (supervisedMode === 'classification') {
                supervisedData.classification.push({ x, y, class: currentClass });
                currentClass = 1 - currentClass; // Toggle between 0 and 1
                drawSupervisedCanvas();
            } else if (supervisedMode === 'regression') {
                supervisedData.regression.push({ x, y });
                drawSupervisedCanvas();
            }
        });

        function trainModel() {
            if (supervisedMode === 'classification' && supervisedData.classification.length > 0) {
                trainClassification();
            } else if (supervisedMode === 'regression' && supervisedData.regression.length > 0) {
                trainRegression();
            } else {
                updateSupervisedStatus('אנא הוסף נקודות לפני אימון המודל', 'error');
            }
        }

        function trainClassification() {
            // Simple linear classifier using perceptron
            const data = supervisedData.classification;
            let w0 = Math.random() * 2 - 1;
            let w1 = Math.random() * 2 - 1;
            let b = Math.random() * 2 - 1;
            const learningRate = 0.01;
            
            // Normalize coordinates
            const normalized = data.map(d => ({
                x: (d.x / supervisedCanvas.width) * 2 - 1,
                y: (d.y / supervisedCanvas.height) * 2 - 1,
                class: d.class
            }));

            // Training loop
            for (let epoch = 0; epoch < 1000; epoch++) {
                let error = 0;
                for (const point of normalized) {
                    const prediction = (w0 * point.x + w1 * point.y + b) > 0 ? 1 : 0;
                    const target = point.class;
                    const delta = target - prediction;
                    
                    if (delta !== 0) {
                        w0 += learningRate * delta * point.x;
                        w1 += learningRate * delta * point.y;
                        b += learningRate * delta;
                        error += Math.abs(delta);
                    }
                }
                if (error === 0) break;
            }

            // Draw decision boundary
            drawSupervisedCanvas();
            supervisedCtx.strokeStyle = '#000000';
            supervisedCtx.lineWidth = 3;
            supervisedCtx.beginPath();
            
            // Draw line: w0*x + w1*y + b = 0
            // y = (-w0*x - b) / w1
            for (let x = 0; x < supervisedCanvas.width; x++) {
                const normX = (x / supervisedCanvas.width) * 2 - 1;
                const normY = (-w0 * normX - b) / w1;
                const y = ((normY + 1) / 2) * supervisedCanvas.height;
                
                if (x === 0) {
                    supervisedCtx.moveTo(x, y);
                } else {
                    supervisedCtx.lineTo(x, y);
                }
            }
            supervisedCtx.stroke();
            
            updateSupervisedStatus(`מודל אומן בהצלחה! קו ההפרדה מצויר בשחור.`, 'info');
        }

        function trainRegression() {
            // Simple linear regression
            const data = supervisedData.regression;
            if (data.length < 2) {
                updateSupervisedStatus('נדרשות לפחות 2 נקודות לרגרסיה', 'error');
                return;
            }

            // Calculate linear regression
            const n = data.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
            
            for (const point of data) {
                sumX += point.x;
                sumY += point.y;
                sumXY += point.x * point.y;
                sumXX += point.x * point.x;
            }

            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;

            // Draw regression line
            drawSupervisedCanvas();
            supervisedCtx.strokeStyle = '#000000';
            supervisedCtx.lineWidth = 3;
            supervisedCtx.beginPath();
            supervisedCtx.moveTo(0, intercept);
            supervisedCtx.lineTo(supervisedCanvas.width, slope * supervisedCanvas.width + intercept);
            supervisedCtx.stroke();

            const r2 = calculateR2(data, slope, intercept);
            updateSupervisedStatus(`מודל אומן בהצלחה! קו המגמה מצויר בשחור. R² = ${r2.toFixed(3)}`, 'info');
        }

        function calculateR2(data, slope, intercept) {
            const meanY = data.reduce((sum, p) => sum + p.y, 0) / data.length;
            let ssRes = 0, ssTot = 0;
            for (const point of data) {
                const predicted = slope * point.x + intercept;
                ssRes += Math.pow(point.y - predicted, 2);
                ssTot += Math.pow(point.y - meanY, 2);
            }
            return 1 - (ssRes / ssTot);
        }

        function drawSupervisedCanvas() {
            supervisedCtx.clearRect(0, 0, supervisedCanvas.width, supervisedCanvas.height);
            
            // Draw grid
            drawGrid(supervisedCtx, supervisedCanvas.width, supervisedCanvas.height);

            if (supervisedMode === 'classification') {
                supervisedData.classification.forEach(point => {
                    supervisedCtx.fillStyle = point.class === 0 ? '#000000' : '#666666';
                    supervisedCtx.beginPath();
                    supervisedCtx.arc(point.x, point.y, 8, 0, Math.PI * 2);
                    supervisedCtx.fill();
                });
            } else if (supervisedMode === 'regression') {
                supervisedData.regression.forEach(point => {
                    supervisedCtx.fillStyle = '#000000';
                    supervisedCtx.beginPath();
                    supervisedCtx.arc(point.x, point.y, 8, 0, Math.PI * 2);
                    supervisedCtx.fill();
                });
            }
        }

        function clearSupervisedCanvas() {
            supervisedCtx.clearRect(0, 0, supervisedCanvas.width, supervisedCanvas.height);
            drawGrid(supervisedCtx, supervisedCanvas.width, supervisedCanvas.height);
        }

        function clearCanvas() {
            if (supervisedMode === 'classification') {
                supervisedData.classification = [];
            } else if (supervisedMode === 'regression') {
                supervisedData.regression = [];
            }
            clearSupervisedCanvas();
            updateSupervisedStatus('הקנבס נוקה');
        }

        function updateSupervisedStatus(message, type = 'info') {
            const status = document.getElementById('supervisedStatus');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        // ========== UNSUPERVISED LEARNING ==========
        const unsupervisedCanvas = document.getElementById('unsupervisedCanvas');
        const unsupervisedCtx = unsupervisedCanvas.getContext('2d');
        let k = 3;

        function initClustering() {
            unsupervisedMode = 'clustering';
            unsupervisedData = [];
            clusters = [];
            generateRandomData();
            drawUnsupervisedCanvas();
            updateUnsupervisedStatus('לחץ על "הרץ קיבוץ" כדי לקבץ את הנקודות');
        }

        function initPCA() {
            unsupervisedMode = 'pca';
            unsupervisedData = generate3DData();
            drawPCA();
            updateUnsupervisedStatus('PCA: הנתונים מוצגים במרחב דו-ממדי');
        }

        function generateRandomData() {
            unsupervisedData = [];
            const centers = [
                { x: 200, y: 200 },
                { x: 600, y: 200 },
                { x: 400, y: 400 }
            ];
            
            for (let i = 0; i < 50; i++) {
                const center = centers[Math.floor(Math.random() * centers.length)];
                unsupervisedData.push({
                    x: center.x + (Math.random() - 0.5) * 150,
                    y: center.y + (Math.random() - 0.5) * 150,
                    cluster: -1
                });
            }
        }

        function generate3DData() {
            const data = [];
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * 400 - 200;
                const y = Math.random() * 400 - 200;
                const z = x * 0.5 + y * 0.3 + (Math.random() - 0.5) * 50;
                data.push({ x, y, z });
            }
            return data;
        }

        function runClustering() {
            if (unsupervisedMode !== 'clustering' || unsupervisedData.length === 0) {
                updateUnsupervisedStatus('אנא לחץ על "התחל קיבוץ" תחילה', 'error');
                return;
            }

            // K-Means algorithm
            k = parseInt(document.getElementById('kSlider').value);
            
            // Initialize centroids randomly
            clusters = [];
            for (let i = 0; i < k; i++) {
                clusters.push({
                    x: Math.random() * unsupervisedCanvas.width,
                    y: Math.random() * unsupervisedCanvas.height,
                    points: []
                });
            }

            // K-Means iteration
            for (let iter = 0; iter < 20; iter++) {
                // Assign points to nearest centroid
                unsupervisedData.forEach(point => {
                    let minDist = Infinity;
                    let nearestCluster = 0;
                    clusters.forEach((cluster, idx) => {
                        const dist = Math.sqrt(
                            Math.pow(point.x - cluster.x, 2) + 
                            Math.pow(point.y - cluster.y, 2)
                        );
                        if (dist < minDist) {
                            minDist = dist;
                            nearestCluster = idx;
                        }
                    });
                    point.cluster = nearestCluster;
                });

                // Update centroids
                clusters.forEach((cluster, idx) => {
                    const clusterPoints = unsupervisedData.filter(p => p.cluster === idx);
                    if (clusterPoints.length > 0) {
                        cluster.x = clusterPoints.reduce((sum, p) => sum + p.x, 0) / clusterPoints.length;
                        cluster.y = clusterPoints.reduce((sum, p) => sum + p.y, 0) / clusterPoints.length;
                    }
                });
            }

            drawUnsupervisedCanvas();
            updateUnsupervisedStatus(`קיבוץ הושלם עם ${k} קבוצות`);
        }

        function drawPCA() {
            unsupervisedCtx.clearRect(0, 0, unsupervisedCanvas.width, unsupervisedCanvas.height);
            drawGrid(unsupervisedCtx, unsupervisedCanvas.width, unsupervisedCanvas.height);

            // Simple 2D projection (simplified PCA)
            const centerX = unsupervisedCanvas.width / 2;
            const centerY = unsupervisedCanvas.height / 2;
            const scale = 0.5;

            unsupervisedData.forEach(point => {
                const x = centerX + point.x * scale;
                const y = centerY + point.y * scale;
                unsupervisedCtx.fillStyle = '#000000';
                unsupervisedCtx.beginPath();
                unsupervisedCtx.arc(x, y, 5, 0, Math.PI * 2);
                unsupervisedCtx.fill();
            });
        }

        function drawUnsupervisedCanvas() {
            unsupervisedCtx.clearRect(0, 0, unsupervisedCanvas.width, unsupervisedCanvas.height);
            drawGrid(unsupervisedCtx, unsupervisedCanvas.width, unsupervisedCanvas.height);

            if (unsupervisedMode === 'clustering') {
                const grays = ['#000000', '#333333', '#666666', '#999999', '#cccccc', '#ffffff', '#2a2a2a', '#555555'];
                
                // Draw points
                unsupervisedData.forEach(point => {
                    const color = point.cluster >= 0 ? grays[point.cluster % grays.length] : '#999';
                    unsupervisedCtx.fillStyle = color;
                    unsupervisedCtx.beginPath();
                    unsupervisedCtx.arc(point.x, point.y, 8, 0, Math.PI * 2);
                    unsupervisedCtx.fill();
                });

                // Draw centroids
                clusters.forEach((cluster, idx) => {
                    const color = grays[idx % grays.length];
                    unsupervisedCtx.fillStyle = color;
                    unsupervisedCtx.strokeStyle = '#000';
                    unsupervisedCtx.lineWidth = 3;
                    unsupervisedCtx.beginPath();
                    unsupervisedCtx.arc(cluster.x, cluster.y, 15, 0, Math.PI * 2);
                    unsupervisedCtx.fill();
                    unsupervisedCtx.stroke();
                });
            }
        }

        function clearUnsupervisedCanvas() {
            unsupervisedCtx.clearRect(0, 0, unsupervisedCanvas.width, unsupervisedCanvas.height);
            drawGrid(unsupervisedCtx, unsupervisedCanvas.width, unsupervisedCanvas.height);
            unsupervisedData = [];
            clusters = [];
            updateUnsupervisedStatus('הקנבס נוקה');
        }

        function updateKValue() {
            k = parseInt(document.getElementById('kSlider').value);
            document.getElementById('kValue').textContent = k;
        }

        function updateUnsupervisedStatus(message, type = 'info') {
            const status = document.getElementById('unsupervisedStatus');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        // ========== REINFORCEMENT LEARNING ==========
        const rlCanvas = document.getElementById('rlCanvas');
        const rlCtx = rlCanvas.getContext('2d');

        function initRL() {
            rlGame = {
                agent: { x: 50, y: 50 },
                goal: { x: 700, y: 400 },
                obstacles: [
                    { x: 200, y: 100, w: 100, h: 20 },
                    { x: 400, y: 200, w: 20, h: 100 },
                    { x: 300, y: 350, w: 150, h: 20 },
                    { x: 600, y: 250, w: 20, h: 80 }
                ],
                qTable: {},
                episodes: 0,
                successCount: 0
            };
            drawRL();
            updateRLStatus('משחק מוכן. לחץ על "אמן סוכן" כדי להתחיל אימון.');
        }

        function trainRL() {
            if (!rlGame) {
                initRL();
            }

            // Q-Learning training
            const episodes = 100;
            const alpha = 0.1; // Learning rate
            const gamma = 0.9; // Discount factor
            const epsilon = 0.1; // Exploration rate

            for (let ep = 0; ep < episodes; ep++) {
                let state = { x: rlGame.agent.x, y: rlGame.agent.y };
                let steps = 0;
                const maxSteps = 200;

                while (steps < maxSteps) {
                    const stateKey = `${state.x},${state.y}`;
                    if (!rlGame.qTable[stateKey]) {
                        rlGame.qTable[stateKey] = { up: 0, down: 0, left: 0, right: 0 };
                    }

                    // Choose action (epsilon-greedy)
                    let action;
                    if (Math.random() < epsilon) {
                        const actions = ['up', 'down', 'left', 'right'];
                        action = actions[Math.floor(Math.random() * actions.length)];
                    } else {
                        const qValues = rlGame.qTable[stateKey];
                        action = Object.keys(qValues).reduce((a, b) => qValues[a] > qValues[b] ? a : b);
                    }

                    // Execute action
                    const newState = executeAction(state, action);
                    const reward = getReward(newState);
                    const done = reward > 0 || reward < -10;

                    // Update Q-value
                    const newStateKey = `${newState.x},${newState.y}`;
                    if (!rlGame.qTable[newStateKey]) {
                        rlGame.qTable[newStateKey] = { up: 0, down: 0, left: 0, right: 0 };
                    }
                    const maxNextQ = Math.max(...Object.values(rlGame.qTable[newStateKey]));
                    rlGame.qTable[stateKey][action] += alpha * (reward + gamma * maxNextQ - rlGame.qTable[stateKey][action]);

                    state = newState;
                    steps++;

                    if (done) {
                        if (reward > 0) rlGame.successCount++;
                        break;
                    }
                }

                rlGame.episodes++;
                // Reset agent position
                rlGame.agent = { x: 50, y: 50 };
            }

            // Visualize best path
            visualizeBestPath();
            updateRLStatus(`אימון הושלם! ${rlGame.episodes} איטרציות, ${rlGame.successCount} הצלחות`);
        }

        function executeAction(state, action) {
            let newState = { ...state };
            const stepSize = 10;

            switch (action) {
                case 'up': newState.y = Math.max(0, state.y - stepSize); break;
                case 'down': newState.y = Math.min(rlCanvas.height - 20, state.y + stepSize); break;
                case 'left': newState.x = Math.max(0, state.x - stepSize); break;
                case 'right': newState.x = Math.min(rlCanvas.width - 20, state.x + stepSize); break;
            }

            // Check collision with obstacles
            for (const obs of rlGame.obstacles) {
                if (newState.x < obs.x + obs.w && newState.x + 20 > obs.x &&
                    newState.y < obs.y + obs.h && newState.y + 20 > obs.y) {
                    return state; // Stay in place if collision
                }
            }

            return newState;
        }

        function getReward(state) {
            // Check if reached goal
            if (Math.abs(state.x - rlGame.goal.x) < 30 && Math.abs(state.y - rlGame.goal.y) < 30) {
                return 100;
            }
            // Check collision
            for (const obs of rlGame.obstacles) {
                if (state.x < obs.x + obs.w && state.x + 20 > obs.x &&
                    state.y < obs.y + obs.h && state.y + 20 > obs.y) {
                    return -10;
                }
            }
            // Distance reward
            const dist = Math.sqrt(Math.pow(state.x - rlGame.goal.x, 2) + Math.pow(state.y - rlGame.goal.y, 2));
            return -dist / 100;
        }

        function visualizeBestPath() {
            drawRL();
            let state = { x: rlGame.agent.x, y: rlGame.agent.y };
            const path = [state];
            const visited = new Set();

            for (let i = 0; i < 100; i++) {
                const stateKey = `${state.x},${state.y}`;
                if (visited.has(stateKey)) break;
                visited.add(stateKey);

                if (!rlGame.qTable[stateKey]) break;
                const qValues = rlGame.qTable[stateKey];
                const action = Object.keys(qValues).reduce((a, b) => qValues[a] > qValues[b] ? a : b);
                state = executeAction(state, action);
                path.push(state);

                if (Math.abs(state.x - rlGame.goal.x) < 30 && Math.abs(state.y - rlGame.goal.y) < 30) {
                    break;
                }
            }

            // Draw path
            rlCtx.strokeStyle = '#ffffff';
            rlCtx.lineWidth = 3;
            rlCtx.beginPath();
            path.forEach((p, i) => {
                if (i === 0) {
                    rlCtx.moveTo(p.x + 10, p.y + 10);
                } else {
                    rlCtx.lineTo(p.x + 10, p.y + 10);
                }
            });
            rlCtx.stroke();
        }

        function drawRL() {
            rlCtx.clearRect(0, 0, rlCanvas.width, rlCanvas.height);
            drawGrid(rlCtx, rlCanvas.width, rlCanvas.height);

            if (!rlGame) return;

            // Draw obstacles
            rlCtx.fillStyle = '#333333';
            rlGame.obstacles.forEach(obs => {
                rlCtx.fillRect(obs.x, obs.y, obs.w, obs.h);
            });

            // Draw goal
            rlCtx.fillStyle = '#ffffff';
            rlCtx.beginPath();
            rlCtx.arc(rlGame.goal.x, rlGame.goal.y, 25, 0, Math.PI * 2);
            rlCtx.fill();
            rlCtx.strokeStyle = '#000000';
            rlCtx.lineWidth = 2;
            rlCtx.stroke();

            // Draw agent
            rlCtx.fillStyle = '#000000';
            rlCtx.fillRect(rlGame.agent.x, rlGame.agent.y, 20, 20);
        }

        function resetRL() {
            rlGame = null;
            drawRL();
            updateRLStatus('משחק אופס');
        }

        function updateRLStatus(message, type = 'info') {
            const status = document.getElementById('rlStatus');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        function updateSpeed() {
            animationSpeed = parseInt(document.getElementById('speedSlider').value);
            document.getElementById('speedValue').textContent = animationSpeed;
        }

        // ========== DEEP LEARNING ==========
        const deepCanvas = document.getElementById('deepCanvas');
        const deepCtx = deepCanvas.getContext('2d');
        let numLayers = 3;
        let neuronsPerLayer = 4;

        function initNeuralNetwork() {
            neuralNetwork = {
                layers: [],
                weights: []
            };

            // Create layers
            for (let i = 0; i < numLayers; i++) {
                neuralNetwork.layers.push([]);
                for (let j = 0; j < neuronsPerLayer; j++) {
                    neuralNetwork.layers[i].push({
                        x: 0,
                        y: 0,
                        activation: 0
                    });
                }
            }

            // Initialize weights
            for (let i = 0; i < numLayers - 1; i++) {
                neuralNetwork.weights.push([]);
                for (let j = 0; j < neuralNetwork.layers[i].length; j++) {
                    neuralNetwork.weights[i].push([]);
                    for (let k = 0; k < neuralNetwork.layers[i + 1].length; k++) {
                        neuralNetwork.weights[i][j].push(Math.random() * 2 - 1);
                    }
                }
            }

            drawNeuralNetwork();
            updateDeepStatus('רשת נוצרה. לחץ על "אמן רשת" כדי להתחיל אימון.');
        }

        function trainNeuralNetwork() {
            if (!neuralNetwork) {
                initNeuralNetwork();
            }

            // Simulate forward pass
            for (let epoch = 0; epoch < 10; epoch++) {
                // Random input
                const input = Array(neuronsPerLayer).fill(0).map(() => Math.random());
                
                // Forward pass
                for (let i = 0; i < neuralNetwork.layers.length; i++) {
                    if (i === 0) {
                        // Input layer
                        neuralNetwork.layers[i].forEach((neuron, idx) => {
                            neuron.activation = input[idx];
                        });
                    } else {
                        // Hidden/output layers
                        neuralNetwork.layers[i].forEach((neuron, idx) => {
                            let sum = 0;
                            neuralNetwork.layers[i - 1].forEach((prevNeuron, prevIdx) => {
                                sum += prevNeuron.activation * neuralNetwork.weights[i - 1][prevIdx][idx];
                            });
                            neuron.activation = sigmoid(sum);
                        });
                    }
                }

                // Update weights (simplified backpropagation)
                for (let i = neuralNetwork.weights.length - 1; i >= 0; i--) {
                    for (let j = 0; j < neuralNetwork.weights[i].length; j++) {
                        for (let k = 0; k < neuralNetwork.weights[i][j].length; k++) {
                            const error = Math.random() * 0.1 - 0.05;
                            neuralNetwork.weights[i][j][k] += error;
                        }
                    }
                }

                drawNeuralNetwork();
            }

            updateDeepStatus('אימון הושלם! הרשת עודכנה.');
        }

        function sigmoid(x) {
            return 1 / (1 + Math.exp(-x));
        }

        function drawNeuralNetwork() {
            deepCtx.clearRect(0, 0, deepCanvas.width, deepCanvas.height);
            deepCtx.fillStyle = '#ffffff';
            deepCtx.fillRect(0, 0, deepCanvas.width, deepCanvas.height);

            if (!neuralNetwork || neuralNetwork.layers.length === 0) return;

            const layerSpacing = deepCanvas.width / (neuralNetwork.layers.length + 1);
            const neuronRadius = 20;

            // Calculate neuron positions
            neuralNetwork.layers.forEach((layer, layerIdx) => {
                const x = layerSpacing * (layerIdx + 1);
                const neuronSpacing = deepCanvas.height / (layer.length + 1);
                
                layer.forEach((neuron, neuronIdx) => {
                    neuron.x = x;
                    neuron.y = neuronSpacing * (neuronIdx + 1);
                });
            });

            // Draw connections
            deepCtx.strokeStyle = '#666';
            deepCtx.lineWidth = 1;
            for (let i = 0; i < neuralNetwork.weights.length; i++) {
                neuralNetwork.layers[i].forEach((neuron, j) => {
                    neuralNetwork.layers[i + 1].forEach((nextNeuron, k) => {
                        const weight = neuralNetwork.weights[i][j][k];
                        const intensity = Math.abs(weight) * 255;
                        deepCtx.strokeStyle = weight > 0 ? `rgba(${intensity}, ${intensity}, ${intensity}, 0.5)` : `rgba(${intensity}, ${intensity}, ${intensity}, 0.3)`;
                        deepCtx.lineWidth = Math.abs(weight) * 3;
                        deepCtx.beginPath();
                        deepCtx.moveTo(neuron.x, neuron.y);
                        deepCtx.lineTo(nextNeuron.x, nextNeuron.y);
                        deepCtx.stroke();
                    });
                });
            }

            // Draw neurons
            neuralNetwork.layers.forEach(layer => {
                layer.forEach(neuron => {
                    // Neuron circle
                    const intensity = Math.min(255, Math.max(0, neuron.activation * 255));
                    deepCtx.fillStyle = `rgb(${intensity}, ${intensity}, ${intensity})`;
                    deepCtx.beginPath();
                    deepCtx.arc(neuron.x, neuron.y, neuronRadius, 0, Math.PI * 2);
                    deepCtx.fill();
                    
                    // Neuron border
                    deepCtx.strokeStyle = '#000';
                    deepCtx.lineWidth = 2;
                    deepCtx.stroke();
                });
            });
        }

        function resetNeuralNetwork() {
            neuralNetwork = null;
            deepCtx.clearRect(0, 0, deepCanvas.width, deepCanvas.height);
            updateDeepStatus('רשת אופסה');
        }

        function updateLayers() {
            numLayers = parseInt(document.getElementById('layersSlider').value);
            document.getElementById('layersValue').textContent = numLayers;
            if (neuralNetwork) {
                initNeuralNetwork();
            }
        }

        function updateNeurons() {
            neuronsPerLayer = parseInt(document.getElementById('neuronsSlider').value);
            document.getElementById('neuronsValue').textContent = neuronsPerLayer;
            if (neuralNetwork) {
                initNeuralNetwork();
            }
        }

        function updateDeepStatus(message, type = 'info') {
            const status = document.getElementById('deepStatus');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        // ========== UTILITY FUNCTIONS ==========
        function drawGrid(ctx, width, height) {
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 1;
            
            // Vertical lines
            for (let x = 0; x <= width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = 0; y <= height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
        }

        // Initialize
        drawGrid(supervisedCtx, supervisedCanvas.width, supervisedCanvas.height);
        drawGrid(unsupervisedCtx, unsupervisedCanvas.width, unsupervisedCanvas.height);
        drawGrid(rlCtx, rlCanvas.width, rlCanvas.height);
    </script>
</body>
</html>
